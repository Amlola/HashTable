# Хеш-таблица
## Описание проекта  
В данной проекте проводится два этапа работы:  
- **Исследование Хеш-функций** - сравнение различных хеш-функций по нескольким параметрам.
- **Оптимизация функций** - профилирование программы и ускорение нужного объекта оптимизации.
## Структура данных Хеш-таблица
Хеш-таблица - это структура данных, хранящая пары элементов ключ-значение. В нашем случае ключами являются английские слова, а значением количество таких слов в тексте. В данной реализации хеш-таблица представляет из себя массив двусвязных списков, индексы которого соответствуют результату хеш-функции (обратите внимание на пункт `Note` ниже). Выполняет три основные операции: добавление, удаление и поиск ключа в таблице по значению. Мы определяем функцию хеширования, которая по каждому входящему элементу будет определять натуральное число. А уже дальше по этому натуральному числу мы будем класть элемент в двусвязный список (его реализация также представлена в данном репозитории), тем самым заполняя хеш-таблицу.   

Иногда возникает проблема, когда хеш-функция выдает одинаковое натуральное число для разных элементов. Такая ситуация называется коллизией. Ниже представлена картинка, которая отображает вышеизложенную информацию. 

![Окно](img/hashtable.png)

> [!NOTE]
> Результат хеш-функции берется по модулю размера таблицы. В даннной реализации размер хеш-таблицы простое число. Это нужно для того, чтобы получить более случайное распределение ключей.

### Фактор загрузки
Фактор загрузки это отношение количества элементов к размеру хеш-таблицы, то есть ожидаемое количество элементов в одной ячейке таблицы. В данном проекте для анализа взято произведение ```"Война и Мир"``` (в английском переводе), хранящее в себе 18257 уникальных слов, а также ни одного слова длиной больше 32 букв (важно при выполнении второй части данной работы). При обработке текста были "выброшены" все знаки препинания, а также слова приведены к строчному виду. В данном исследовании функций был подобраный такой размер хеш-таблицы (```2551```), чтобы коэффицент загрузки составлял примерно ```7```. Это нужно, чтобы было лучше видно неравномерность распределения. В реальных задачах он составляет примерно ```0.75-1.5```.

## Исследование Хеш-функций
Распределение хеш-функций будут визуализированы с помощью гистограмм. По горизонтали номер списка в таблице, А по вертикали количество элементов в соответствующем списке. А критерием сравнения функций будет являться ```дисперсия```, так как она определяет среднюю длину списка. Поэтому чем меньше ее значение, тем лучше функция.   
> [!NOTE]
> В скобках будут указаны краткие обозначения функций, которые будут использоваться дальше. 
### Функция, возвращающая константу (constant)
В данном случае всегда возвращается число 5.

![Окно](img/constant_func.png)

### Функция, возвращающая ASCII код первого символа слова (word[0])

![Окно](img/word[0].png)

### Функция, возвращающая длину слова (strlen)

![Окно](img/strlen.png)

### Функция, возвращающая сумму ASCII кодов слова
Данная функция будет исследована при стандартном размере хеш-таблицы (**ascii1**) и при размере ```239``` (**ascii2**). Для второго из них значение коэффицента загрузки составляет приблизительно 76. 

![Окно](img/ascii2.png)

Из гистограммы может показаться, что данная хеш-функция является "хорошей" поскольку мы видим достаточно равномерное распределение. Но теперь исследуем эту функцию при стандартном размере таблицы.  

![Окно](img/ascii.png)

Мы видим, что в этом случае уже нет никакого равномерного распределения. Это связано с огранниченостью длины английский слов. Так как коды маленьких английских букв лежат в диапазоне от 97 до 122, то при большом размере хеш-таблицы в последних ячейках уже не будет находиться элементов.  
Однако, можно заметить, что среди четырех представленных функций, она является лучшей, поскольку значение дисперсии является самым маленьким.

### Функция, возвращающая сумму ASCII кодов слова, деленную на длину (sumdivlen)

![Окно](img/sumdivlen.png)


### Функция с использованием циклического сдвига вправо (Ror)
Алгоритм данной хеш-функции следующий: В цикле выполняется циклический сдвиг значения хеша вправо на 1 бит, после этого делается ```xor``` с текущим символом слова. Полученное значение становится новым для хеша. Количество итераций цикла равняется длине слова.

![Окно](img/ror.png)

### Функция с использованием циклического сдвига влево (Rol)
Алгоритм аналогичен **Ror**, только сдвиг происходит влево.

![Окно](img/rol.png)

Данные хеш-функции уже значительно лучше предыдущих, так как показатель дисперсии меньше. Но можно отметить, что **Rol** является предпочтительнее.

### Интересное замечание
В языке C нет команд циклического сдвига. Но современные компиляторы производят ```backend``` оптимизацию. То есть написанная функция циклического сдвига, например Rol, с включенным уровнем оптимизации -O3 будет распознана компилятором и заменена в одну команду.

![Окно](img/godboltO3.png)

### Функция Crc-32
Об алгоритме данной хеш-функции можно прочитать здесь [`Crc-32`](https://ru.wikipedia.org/wiki/Crc)
![Окно](img/crc32.png)

## Анализ полученных результатов
Представим значения дисперсий в таблице

![Окно](img/pinoccio.png)
| Функция\Параметр          |   Дисперсия   |
|:--------------------------|:-------------:|
|**constant**               | 130661.72     |
|**word[0]**                | 7536.28       |
|**strlen**                 | 15169.32      |
|**ascii2**                 | 173.83        | 
|**ascii1**                 | 588.61        | 
|**sumdivlen**              | 12216.65      | 
|**Ror**                    | 31.46         | 
|**Rol**                    | 10.43         |
|**Crc-32**                 | 7.38          |

Среди исследованных функций лучшей является **Crc-32**. Этот результат является ожидаемым, поскольку данный алгоритм используется на практике, например в протоколах передачи данных. Во второй части данного проекта будем использовать именно эту хеш-функцию.
