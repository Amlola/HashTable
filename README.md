# Хеш-таблица
## Описание проекта  
В данной проекте проводится два этапа работы:  
- **Исследование Хеш-функций** - сравнение различных хеш-функций по нескольким параметрам.
- **Оптимизация функций** - профилирование программы и ускорение нужного объекта оптимизации.
## Структура данных Хеш-таблица
Хеш-таблица - это структура данных, хранящая пары элементов ключ-значение. В нашем случае ключами являются английские слова, а значением количество таких слов в тексте. В данной реализации хеш-таблица представляет из себя массив двусвязных списков, индексы которого соответствуют результату хеш-функции (обратите внимание на пункт `Note` ниже). Выполняет три основные операции: добавление, удаление и поиск ключа в таблице по значению. Мы определяем функцию хеширования, которая по каждому входящему элементу будет определять натуральное число. А уже дальше по этому натуральному числу мы будем класть элемент в двусвязный список (его реализация также представлена в данном репозитории), тем самым заполняя хеш-таблицу.   

Иногда возникает проблема, когда хеш-функция выдает одинаковое натуральное число для разных элементов. Такая ситуация называется коллизией. Ниже представлена картинка, которая отображает вышеизложенную информацию. 

![Окно](img/constant_func.png)

> [!NOTE]
> Результат хеш-функции берется по модулю размера таблицы. В даннной реализации размер хеш-таблицы простое число. Это нужно для того, чтобы получить более случайное распределение ключей.

### Фактор загрузки
Фактор загрузки это отношение количества элементов к размеру хеш-таблицы, то есть ожидаемое количество элементов в одной ячейке таблицы. В данном проекте для анализа взято произведение ```"Война и Мир"``` (в английском переводе), хранящее в себе 18257 уникальных слов, а также ни одного слова длиной больше 32 букв (важно при выполнении второй части данной работы). При обработке текста были "выброшены" все знаки препинания, а также слова приведены к строчному виду. В данном исследовании функций был подобраный такой размер хеш-таблицы (```2551```), чтобы коэффицент загрузки составлял примерно ```7```. Это нужно, чтобы было лучше видно неравномерность распределения. В реальных задачах он составляет примерно ```0.75-1.5```.

## Исследование Хеш-функций
Распределение хеш-функций будут визуализированы с помощью гистограмм. По горизонтали номер списка в таблице, А по вертикали количество элементов в соответствующем списке. А критерием сравнения функций будет являться ```дисперсия```, так как она определяет среднюю длину списка. Поэтому чем меньше ее значение, тем лучше функция.   
> [!NOTE]
> В скобках будут указаны краткие обозначения функций, которые будут использоваться дальше. 
### Функция, возвращающая константу (constant)

![Окно](img/constant_func.png)

### Функция, возвращающая ASCII код первого символа слова (word[0])

![Окно](img/word[0].png)

### Функция, возвращающая длину слова (strlen)

![Окно](img/strlen.png)

### Функция, возвращающая сумму ASCII кодов слова
Данная функция будет исследована при стандартном размере хеш-таблицы (**ascii1**) и при размере ```239``` (**ascii2**). Для второго из них значение коэффицента загрузки составляет приблизительно 76. 

![Окно](img/ascii2.png)

Из гистограммы может показаться, что данная хеш-функция является "хорошей" поскольку мы видим достаточно равномерное распределение. Но теперь исследуем эту функцию при стандартном размере таблицы.  

![Окно](img/ascii.png)

Мы видим, что в этом случае уже нет никакого равномерного распределения. Это связано с огранниченостью длины английский слов. Так как коды маленьких английских букв лежат в диапазоне от 97 до 122, то при большом размере хеш-таблицы в последних ячейках уже не будет находиться элементов.  
Однако, можно заметить, что среди четырех представленных функций, она является лучшей, поскольку значение дисперсии является самым маленьким.

### Функция, возвращающая сумму ASCII кодов слова, деленную на длину (sumdivlen)

![Окно](img/sumdivlen.png)


### Функция с использованием циклического сдвига вправо (Ror)
Алгоритм данной хеш-функции следующий: В цикле выполняется циклический сдвиг значения хеша вправо на 1 бит, после этого делается ```xor``` с текущим символом слова. Полученное значение становится новым для хеша. Количество итераций цикла равняется длине слова.

![Окно](img/ror.png)

### Функция с использованием циклического сдвига влево (Rol)
Алгоритм аналогичен **Ror**, только сдвиг происходит влево.

![Окно](img/rol.png)

### Интересное замечание
В языке C нет команд циклического сдвига. Но современные компиляторы производят ```backend``` оптимизацию. То есть написанная функция циклического сдвига, например Rol, с включенным уровнем оптимизации -O3 будет распознана компилятором и заменена в одну команду.

![Окно](img/godboltO0.png)

![Окно](img/crc32.png)

![Окно](img/pinoccio.png)
| Функция\Параметр          |   Дисперсия   |
|:--------------------------|:-------------:|
|Returning a constant       | 130661.72     |
|Ascii code first letter    | 7536.28       |
|Word length                | 15169.32      |
|Сhecksum Ascii size 100    | 173.83        | 
|Сhecksum Ascii base size   | 588.61        | 
|Checksum divided by length | 12216.65      | 
|Ror                        | 31.46         | 
|Rol                        | 10.43         |
|Crc-32                     | 7.38          |
